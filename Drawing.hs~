module Drawing where

import Graphics.Gloss
import Data.Foldable
import Data.Matrix

import Game

drawHline :: Float -> Float -> Picture
drawHline pos totalSide = translate 0 pos $ rectangleSolid totalSide (totalSide/40)

drawVline :: Float -> Float -> Picture
drawVline pos totalSide = translate pos 0 $ rectangleSolid (totalSide/40) totalSide

drawGrid :: Dimension -> Picture
drawGrid (n, side) = pictures $
                   [ drawVline ((i - nf / 2) * side) tside
                   | i <- [1 .. nf - 1]] ++
                   [ drawHline ((i - nf / 2) * side) tside
                   | i <- [1 .. nf - 1]]
  where
    nf = fromIntegral n
    tside = nf * side

drawPlayer :: Float -> Player -> Picture
drawPlayer side X =
  let rect = rectangleSolid (side/8) side
   in pictures
      [ rotate 45 rect
      , rotate (-45) rect
      ]
drawPlayer side O = thickCircle (side/sqrt 2/2) (side/10)

drawBoard :: Dimension -> Board -> Picture
drawBoard d@(n, side)
    = (drawGrid d <>)
    . translate (-side * fromIntegral (n + 1) / 2) (-side * fromIntegral (n + 1) / 2)
    . fold
    . mapPos maybeDraw 
  where
    nf = fromIntegral n
    maybeDraw (i,j) = maybe Blank
                    $ translate (totalSide / nf * fromIntegral i) (totalSide / nf * fromIntegral j)
                    . drawPlayer (totalSide/ fromIntegral n)

drawGame :: Dimension -> Game -> Picture
drawGame d game = changeColor $ drawBoard d $ currentBoard game
  where changeColor =
          case currentState game of
            GameOver (Just X) -> color red
            GameOver (Just O) -> color blue
            GameOver Nothing -> color $ greyN 0.4
            _ -> id
